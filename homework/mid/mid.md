# 系統程式
***
## 組譯程式
### ●指引命令
    START   指定程式名字及設定程式的起始位址。
    END     程式結束，並可指定持式的執行起始位址。
    BYTE    字元或十六進制碼常數。
    WORD    產生一個字組常數。
    RESB    保留數個位元組以供資料操作。
    RESW    保留數個字組以提供資料操作。
### ●基本功能
    1. 將助記憶式指令轉換成相對應的機器碼。
    2. 將符號式運算元轉換成相對應的機器位址。
    3. 依電腦硬體格式產生相對應的機器指令。
    4. 將原始程式內定義的資料常數轉換成機器內部表示的型態。
    5. 輸出目的程式並列出組合語言。
由於某些虛擬指令僅會指示組譯程式做某些動作，並不產生機器碼。至於某些單純的指令，當其翻譯成機器碼後，仍可再還原為原來的指令，所以用組合語言所撰寫的原始程式經過組譯程式組譯成機器碼後，僅部分的原始程式可反組譯回來。
### ●類型
組譯程式依處理方式不同，大致可以分成三大類：
<pre>
    1. 一次處理組譯程式
        a. 載入並且執行
        b. 一次處理模組
    2. 兩次處理組譯程式
    3. 多次處理組譯程式
</pre>
#### 一次處理組譯程式
若程式中所有使用到的符號皆事先定義過，且沒有向前參考的情況，皆可用一次處理組合程式來處理。此類組譯程式有兩種：
<pre>
    1. 載入並且執行：
        此類組譯程式並不產生目的程式，而是直接產生絕對位址式的機器碼，並且立即載入實際的記憶體中執行。載入並且執行組譯程式處理符號的方式則採用鏈結串列，當未定義的符號首次出現時，則將它加於符號表內，並註明上未定義；當此符號再次出現，則利用指標將它連接能來，並記錄此符號的出現位址值。
        ＜缺點＞
        a. 不具連結的能力：
            個別組譯的程式無法結合在一起，成為一個大程式。
        b. 不具重定位的能力：
            程式必須在固定的記憶體未止組譯執行。
        c. 須具備足夠的記憶體空間：
            因為組譯程式本身與機器碼都同時存在於記憶體中。
    2. 一次處理模組：
        此種組譯程式不若載入並且執行組譯程式，它並不產生機器碼，而是產生目的碼，其中亦包含供連結程式及載入程式使用的資訊。其僅完成部分的組譯工作，其餘則交由載入程式處理。此組譯程式處理未定義的符號是以一個跳躍至某一位址的指令替代；即遇到未定義的符號，則將它的位址值加入跳前表中，且記錄它的符號及其出現的位址值，當再有相同的符號出現時，則用鏈結串列的方式將它的位址值串聯．此表格將供載入程式於載入時調整相對應的位址值。
</pre>
#### 兩次處理組譯程式
在做組譯工作時，會對原始程式做兩次掃瞄，所以允許程式中存在向前參考的未定義符號。典型的兩次處理組譯程式，其功能就是在第一次處理時產生一個中間檔案，而於第二次處理時讀取該中間檔案，並處理第一次處理未完成的工作。兩次處理的功能如下：
<pre>
    1. 第一次處理：定義所有的符號與文字。
        a. 決定程式中所有敘述的位址。
        b. 儲存所有標籤的位址，供第二次處理使用。
        c. 處理程式中的虛擬指令。
    2. 第二次處理：輸出目的程式。
        a. 將指令組譯；及翻譯運算碼及符號位址的查詢。
        b. 產生DS, DC及文字所定義的值。
        c. 處理未處理的虛擬指令。
        d. 輸出目的程式並列出原始的組合語言程式。
</pre>
#### 多次處理組譯程式
此種組譯程式在組譯時會對原始程式做多次的掃描，所以允許程式中存在向前參考的未定義符號。於第一次處理時，先保留涉及向前參考之未定義符號，於第二次處理之後，再對這些未定義的符號做若干次的額外處理。如 ＂Vable EQU Expr＂，Expr可以是數值、名稱、運算式子。若Expr是一個名稱，則必須是定義過；否則，需多一次的處理，以便解決此向前參考的情況。   
使用多次處理組譯程式的好處，乃是其提供額外的四種功能：
<pre>
    1. 可以使用巨集指令。
    2. 減少記憶體空間使用量。
    3. 允許向前參考的符號存在，使城市易於撰寫，更具彈性。
    4. 易於程式碼最佳化的處理。
</pre>
***
#### IBM 360
IBM 360組合語言允許參考到事先尚未定義的標記或符號，而這些未定義的標記與符號於稍後才予以定義；即是允許向前參考。由於在事先便已參考到這些未定義的標記與符號，故需要兩回處理組譯程式來處理。
***   
組譯程式的設計方式常採用二次處理，因為一次處理組譯程式需要的記憶體空間較大，且處理時所要建立的資料結構亦較複雜，故通常採用二次處理組譯程式。
#### 問題
在一回合處理組譯程式中，＂向前參考＂的問題在兩回處理組譯程式不會發生，對於此問題可採下列任一方法解決：
<pre>
    1. 轉移向量法。
    2. 回溯法。
</pre>
***
### ●重定位處理
1. 組譯程式在處理重定位址式程式過程
<pre>
    (1) 組譯程式在組譯時，會產生一個命令於目的程式中，這命令會指示載入程式計算載入位址時須加上程式的起始位址。
    (2) 載入程式使用變更記錄內的資訊，以便能將目的程式載入至適當的記憶體位址。
</pre>
2. 絕對位址式程式與重定位址式程式的差異
<pre>
    (1) 絕對位址式程式：
        程式之起始位址於組譯時便已經決定，且每次載入之位地都一樣。
    (2) 重定位址式程式：
        程式之起始位址於載入時才決定，且每次載入之位址不一定每次都一樣。
</pre>
3. 絕對位址式程式的缺點
<pre>
    (1) 記憶體空間不能有效的利用，因每次都占用固定的位址。
    (2) 記憶體無法共用。
    (3) 儲存於記憶體中的目的碼亦造成混淆；即無法判定該值是位址值或是資料值。
    (重定位址式程式，則可彌補上述之缺點。)
</pre>
***
### ●基底暫存器(Base Register)與索引暫存器(Index Register)功能與異同
1. 在基底定址模式中，將基底暫存器內的值與運算元欄位內的值相加，即為存放資料的有效位址值。
2. 在索引定址模式中，將索引暫存器內的值與運算元欄位內的值相加，即是存放資料的有效位址值。
3. 若想讀取記憶體中其他位址的資料，在基底定址模式中，僅可藉由改變運算元欄位內的值，而非修改基底暫存器內的值；但在索引定址模式中，卻是是藉改變索引暫存器的值，而非運算元欄位內的值。
4. 可用基底暫存器與索引暫存器去做重定址與定位的工作。
***
### BACK 6 DC *-6 與 BACK 6 EQU *-6的差異及其在兩次處理組譯程式的運作方式
BACK6 EQU *-6為虛擬指令，在組譯時，組譯程式會將程式中所有的BACK6以指令＂BACK6 EQU *-6＂之位址值減6取代之，且此指令並不會產生機器碼，執行時無須重定位。   
BACK6 DC *-6亦為虛擬指令，在組譯時會告知組譯程式先預留記憶體空間給BACK6，並將指令＂BACK6 DC *-6＂之位址值減6的值儲存於該空間內，此指令執行時會產生機器碼且需要重定位。